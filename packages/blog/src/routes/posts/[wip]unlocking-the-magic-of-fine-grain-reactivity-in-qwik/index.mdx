# Read

- [A Hands-on Introduction to Fine-Grained Reactivity](https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf)
- [Building a Reactive Library from Scratch](https://dev.to/ryansolid/building-a-reactive-library-from-scratch-1i0p)
- [My Take on a Unified Theory of Reactivity](https://www.builder.io/blog/unified-reactivity-theory)
- [A Brief History of Reactivity](https://www.builder.io/blog/history-of-reactivity)
- [Unveiling the Magic: Exploring Reactivity Across Various Frameworks](https://www.builder.io/blog/reactivity-across-frameworks)
- [React’s Upcoming Compiler Only Solves Part Of The Problem](https://www.builder.io/blog/react-compiler-will-not-solve-prop-drilling)

## Not Read

- [SolidJS: Reactivity to Rendering](https://indepth.dev/posts/1289/solidjs-reactivity-to-rendering)
- [Becoming fully reactive: an in-depth explanation of MobX](https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254)

- What is SignalImpl?
- What is SignalDerived?
- What is the reactivity graph?
- Does Qwik support dynamic subscription? Yes, Qwik will clear the subscriptions before it rerun the subscriber.
- How does a subscription happen? Qwik will subscribe the subscriber in the current invoke context when QRL reads from signals.
- How does a notification happen? Qwik will notify the subscribers when signals are updated.
- How does a un-subscription happen? Qwik will clear the subscriptions before it rerun the subscriber.

Reactivity:

- Implicit Template Updates
- Explicit useTask$()
- Explicit useComputed$()
- Explicit useResource$()

Qwik will clear signal before track the signal:

```ts
staticCtx.$containerState$.$subsManager$.$clearSignal$(operation);
const value = trackSignal(operation[2], operation.slice(0, -1));
return setProperty(staticCtx, elm, 'data', jsxToString(value));
```

Qwik will do those things before executing the `useTaskQrl`, `useComputedQrl` and `useResourceQrl`:

{/* prettier-ignore-start */}

- create a new invoke context

  ```ts
  // task
  const iCtx = newInvokeContext(rCtx.$static$.$locale$, el, undefined, 'TaskEvent');

  // resource
  const iCtx = newInvokeContext(rCtx.$static$.$locale$, el, undefined, 'TaskEvent');

  // computed
  const iCtx = newInvokeContext(rCtx.$static$.$locale$, hostElement, undefined, 'ComputedEvent');
  ```

{/* prettier-ignore-end */}

- set subscriber to the invoke context (iCtx)

  ```ts
  iCtx.$subscriber$ = [0, task];
  ```

- clear the subscriptions for the task

  ```ts
  const taskFn = task.$qrl$.getFn(iCtx, () => {
    subsManager.$clearSub$(task);
  });
  ```

{/* prettier-ignore-start */}
```tsx
// q:id=6
export const Reactivity = component$(() => {
  const firstName = useSignal('John');
  const lastName = useSignal('Smith');
  const showFullName = useSignal(true);

  const displayName = useComputed$(() => {
    if (!showFullName.value) return firstName.value;
    return `${firstName.value} ${lastName.value}`;
  });

  return (
    <div>
      <h1>
        Display Name:
        {/* q:id=7 */}
        {displayName.value}
      </h1>
      <div>
        {/* q:id=8 */}
        <button onClick$={() => (showFullName.value = true)}>show full name</button>
        {/* q:id=9 */}
        <button onClick$={() => (showFullName.value = false)}>only show first name</button>
      </div>
      <div>
        {/* q:id=a */}
        <button onClick$={() => (firstName.value = 'Leo')}>Set first name to Leo</button>
        {/* q:id=b */}
        <button onClick$={() => (lastName.value = 'Nerd')}>Set last name to Nerd</button>
      </div>
      <div>
        {/* q:id=c */}
        <button onClick$={() => (firstName.value = 'Una')}>Set first name to Una</button>
        {/* q:id=d */}
        <button onClick$={() => (lastName.value = 'Chen')}>Set last name to Chen</button>
      </div>
    </div>
  );
});
```
{/* prettier-ignore-end */}

{/* prettier-ignore-start */}
```json
{
  "refs": {
    "8": "3", // element 8 (show full name button) closes over object 3 (signal showFullName)
    "9": "3", // element 9 (show full name button) closes over object 3 (signal showFullName)
    "a": "0", // element a (set first name to leo button) closes over object 0 (signal firstName)
    "b": "1", // element b (set last name to nerd button) closes over object 0 (signal lastName)
    "c": "0", // element c (set first name to una button) closes over object 0 (signal firstName)
    "d": "1"  // element d (set last name to chen button) closes over object 0 (signal lastName)
  },
  "ctx": {},
  "objs": [
    /* 0 */ "\u00125", // firstName signal with object 5 as its value
    /* 1 */ "\u00126", // lastName signal with object 6 as its value
    /* 2 */ "\u0012*7", // a signal with text element as its value
    /* 3 */ "\u00124", // showFullName signal with object 4 as its value
    /* 4 */ true,
    /* 5 */ "John",
    /* 6 */ "Smith",
    /* 7 */ "\u0002/src/reactivity_component_displayname_usecomputed_qzk1i2drlt4.js#Reactivity_component_displayName_useComputed_Qzk1i2DrlT4[0 1 3]", // a QRL <chunk>#<symbol>[<capture>]
    /* 8 */ "\u00112 @0", // signal derived with object 2 as its argument and (p0) => p0.value as its transform function
    /* 9 */ "#7", // the {displayName.value} text node
    /* a */ "\u0003a 3 7 #6 2" // a task [flags, index, qrl, el, resource]
  ],
  "subs": [
    /* 0 */ ["0 a"], // object 0 has a type 0 subscription from the host object a
    /* 1 */ ["0 a"], // object 1 has a type 0 subscription from the host object a
    /* 2 */ ["3 #7 8 #7"], // object 2 has a type 3 subscription from the host #7 and the signal is object 8
    /* 3 */ ["0 a"] // object 3 has a type 0 subscription from the host object a
  ]
}
```
{/* prettier-ignore-end */}

```js
[(p0) => p0.value];
```

`InvokeContext` stores the current invoke context. When this invoke function call the `someSignal.value`, the getter of that signal will add the subscriber onto its subscriptions array in the `LocalSubscriptionManager`.

```ts
export interface InvokeContext {
  $url$: URL | undefined;
  $seq$: number;
  $hostElement$: QwikElement | undefined;
  $element$: Element | undefined;
  $event$: any | undefined;
  $qrl$: QRL<any> | undefined;
  $waitOn$: Promise<any>[] | undefined;
  $subscriber$: Subscriber | null | undefined;
  $renderCtx$: RenderContext | undefined;
  $locale$: string | undefined;
}
```

That's why when some context is invoked, Qwik will replace the invokeContext and restore the original one back after the `invoke` is finished.

```ts
export function invoke<ARGS extends any[] = any[], RET = any>(
  this: any,
  context: InvokeContext | undefined,
  fn: (...args: ARGS) => RET,
  ...args: ARGS
): RET {
  const previousContext = _context;
  let returnValue: RET;
  try {
    _context = context;
    returnValue = fn.apply(this, args);
  } finally {
    _context = previousContext;
  }
  return returnValue;
}
```

Contexts:

- InvokeContext

  Will be stored in `_context` of the `use-core` module.

  ```ts
  export interface InvokeContext {
    $url$: URL | undefined;
    $seq$: number;
    $hostElement$: QwikElement | undefined;
    $element$: Element | undefined;
    $event$: any | undefined;
    $qrl$: QRL<any> | undefined;
    $waitOn$: Promise<any>[] | undefined;
    $subscriber$: Subscriber | null | undefined;
    $renderCtx$: RenderContext | undefined;
    $locale$: string | undefined;
  }
  ```

  `runComputed` will create a new InvokeContext and add itself as `$subscriber$`.

- QContext

  Will be stored in `element["_qc_"]`.

  ```ts
  export interface QContext {
    // the element which owns this context
    $element$: QwikElement;
    // the references of cross over variables
    // ex: [SignalImpl, SignalDerived, ...]
    $refMap$: any[];
    $flags$: number;
    $id$: string;
    $props$: Record<string, any> | null;
    $componentQrl$: QRLInternal<OnRenderFn<any>> | null;
    // parse the attributes into DOM listeners
    // ex: [['on:click', QRL]]
    li: Listener[];
    $seq$: any[] | null;
    $tasks$: SubscriberEffect[] | null;
    $contexts$: Map<string, any> | null;
    $appendStyles$: StyleAppend[] | null;
    $scopeIds$: string[] | null;
    $vdom$: ProcessedJSXNode | null;
    $slots$: ProcessedJSXNode[] | null;
    $dynamicSlots$: QContext[] | null;
    $parent$: QContext | null;
    $slotParent$: QContext | null;
  }
  ```

# Implicit Template Updates

```tsx
export const ImplicitTemplateUpdates = component$(() => {
  const count = useSignal(0);

  return (
    <>
      <button onClick$={() => count.value++}>count++</button>
      <p>Count: {count.value}</p>
    </>
  );
});
```

## Serialized Reactive Graph

```json
{
  "refs": {
    "7": "0"
  },
  "ctx": {},
  "objs": ["\u00121", 0, "\u00110 @0", "#8"],
  "subs": [["3 #8 2 #8"]]
}
```

The objs[0], which is our count signal, has one subscription from #8 text element and its value is derived from objs[2].

#text -> Signal(count)

## Execute the Signal

The signal will be executed in the render phase:

```ts
switch (type) {
  case 3:
  case 4: {
    const elm = operation[3];
    if (!staticCtx.$visited$.includes(elm)) {
      // clear the original #text -> Signal(count) subscription
      staticCtx.$containerState$.$subsManager$.$clearSignal$(operation);
      // track the signal again and derive the value from the signal derive object
      const value = trackSignal(operation[2], operation.slice(0, -1));
      // push operation to the staticCtx.$operations$ array
      return setProperty(staticCtx, elm, 'data', jsxToString(value));
    }
  }
}
```

# Explicit useTask$()

```tsx
export const ExplicitUseTask = component$(() => {
  const count = useSignal(0);
  const delayCount = useSignal(0);

  useTask$(({ track, cleanup }) => {
    track(() => count.value);
    const id = setTimeout(() => (delayCount.value = count.value), 2000);
    cleanup(() => clearTimeout(id));
  });

  return (
    <>
      <button onClick$={() => count.value++}>count++</button>
      <p>Count: {count.value}</p>
      <p>Delayed Count: {delayCount.value}</p>
    </>
  );
});
```

## Serialized Reactivity Graph

```json
{
  "refs": {
    "7": "1"
  },
  "ctx": {},
  "objs": [
    "\u00122",
    "\u00122",
    0,
    "\u00110 @0",
    "#9",
    "\u0002/src/explicitusetask_component_usetask_zocafjjpoia.js#ExplicitUseTask_component_useTask_ZOCAfJjpoiA[1 0]",
    "\u00032 2 5 #6",
    "\u00111 @0",
    "#8"
  ],
  "subs": [["3 #9 3 #9"], ["0 6", "3 #8 7 #8"]]
}
```

- The objs[0], which is our delayed count signal, has one subscription from #9 text element and its value is derived from objs[3].
- The objs[1], which is our count signal, has two subscriptions from the
  - Task, objs[6] `\u00032 2 5 #6`
  - Text element #9 and its value is derived from objs[7] `\u00111 @0`

#text -> Signal(delayed count)
Task -> Signal(count)
#text -> Signal(count)

## Execute subscribers

The Task "0 6" and #text "3 #8 7 #8" subscribers will be executed on the render phase:

runTask:

```ts
const taskFn = task.$qrl$.getFn(iCtx, () => {
  // clear the original subscriptions for this task
  subsManager.$clearSub$(task);
}) as TaskFn;

const track: Tracker = (obj: any, prop?: string) => {
  if (isFunction(obj)) {
    // track the signal explicitly
    const ctx = newInvokeContext();
    ctx.$subscriber$ = [0, task];
    return invoke(ctx, obj);
  }

  // ...
};

const cleanups: (() => void)[] = [];

const opts: TaskCtx = {
  track,
  cleanup(callback) {
    cleanups.push(callback);
  },
};
return safeCall(
  // execute the taskQRL with track and cleanup
  () => taskFn(opts),
  (returnValue) => {
    if (isFunction(returnValue)) {
      cleanups.push(returnValue);
    }
  },
  (reason) => {
    handleError(reason, hostElement, rCtx);
  }
);
```

# Explicit useResource$()

```tsx
export const ExplicitUseResource = component$(() => {
  const count = useSignal(1);
  const pokemonList = useResource$(async ({ track }) => {
    track(() => count.value);
    await new Promise((resolve) => setTimeout(() => resolve(null), 2000));
    return Array(count.value)
      .fill(null)
      .map((_, idx) => `pokemon-${idx + 1} 🐙`);
  });

  return (
    <>
      <button onClick$={() => count.value++}>count++</button>
      <p>Count: {count.value}</p>
      <Resource
        value={pokemonList}
        onPending={() => <h2>loading...</h2>}
        onResolved={(pokemons) => <h2>{pokemons}</h2>}
      />
    </>
  );
});
```

## Serialized Reactivity Graph

```json
{
  "refs": {
    "7": "1"
  },
  "ctx": {
    "6": {
      "h": "9", // host
      "w": "8", // tasks
      "s": "1 0!" // seq
    }
  },
  "objs": [
    /* 0 */ "\u00040 7",
    /* 1 */ "\u00122",
    /* 2 */ 1,
    /* 3 */ "\u00111 @0",
    /* 4 */ "#8",
    /* 5 */ "\u0002/src/explicituseresource_component_pokemonlist_useresource_espcqmn9lr0.js#ExplicitUseResource_component_pokemonList_useResource_eSPCqmN9lr0[1]",
    /* 6 */ "pokemon-1 🐙",
    /* 7 */ ["6"],
    /* 8 */ "\u00034 1 5 #6 0!",
    /* 9 */ "\u0002/src/explicituseresource_component_y5v4flouoas.js#ExplicitUseResource_component_Y5v4FLOUOas"
  ],
  "subs": [
    ["0 #6 __brand", "0 #6 value"],
    ["3 #8 3 #8", "0 8"]
  ]
}
```

- The objs[0], the resource, has two subscriptions from #6 `ExplicitUseResource` component itself.
- The objs[1], the count signal, has two subscriptions from #8 text element and objs[8] `"\u00034 1 5 #6 0!"`

  Task {$flags$: 4, $index$: 1, $el$: '#6', $qrl$: '5', $state$: '0!'}

  The element is #6 which has a serialized context.

  ```json
  "6": {
    "h": "9", // host, the renderQrl
    "w": "8", // tasks
    "s": "1 0!" // seq
  }
  ```

  The above data is parsed and an element context is created.
  That element context is then stored in `#6._qc_`

  The state '0!' is a Resource `"\u00040 7"` wrapped by a Proxy.
  "\u00040 7" means this resource is resolved and its value is objs[7] -> ["pokemon-1 🐙"].
  And this Resource has two subscriptions `"0 #6 __brand"` and `"0 #6 value"`.

  The qrl '5' is a the ResourceQRL that closes over the objs[1], the count Signal.

# Explicit useComputed$()

```tsx
export const ExplicitUseComputed = component$(() => {
  const count = useSignal(0);
  const doubleCount = useComputed$(() => {
    return count.value * 2;
  });

  return (
    <>
      <button onClick$={() => count.value++}>count++</button>
      <p>Count: {count.value}</p>
      <p>Doubled Count: {doubleCount.value}</p>
    </>
  );
});
```

# Automatically Unsubscribe

```tsx
export const AutomaticallyUnsubscribe = component$(() => {
  const count = useSignal(0);

  return (
    <>
      <button onClick$={() => count.value++}>count++</button>
      <p>Count: {count.value}</p>
      {count.value < 3 && <Display count={count} />}
    </>
  );
});

export const Display = component$(({ count }) => {
  return <p>Count: {count.value}</p>;
});
```

# Nested Computed

```tsx
export const NestedComputed = component$(() => {
  const count = useSignal(0);
  const doubleCount = useComputed$(() => {
    return count.value * 2;
  });
  const tripleCount = useComputed$(() => {
    return doubleCount.value + count.value;
  });

  return (
    <>
      <button onClick$={() => count.value++}>count++</button>
      <p>Count: {count.value}</p>
      <p>Doubled Count: {doubleCount.value}</p>
      <p>Tripled Count: {tripleCount.value}</p>
    </>
  );
});
```

# Dynamic Reactivity

```tsx
export const Reactivity = component$(() => {
  const firstName = useSignal('John');
  const lastName = useSignal('Smith');
  const showFullName = useSignal(true);

  const displayName = useComputed$(() => {
    if (!showFullName.value) return firstName.value;
    return `${firstName.value} ${lastName.value}`;
  });

  return (
    <div>
      <h1>Display Name: {displayName.value}</h1>
      <div>
        <button
          onClick$={() => {
            console.log('set showFullName.value = true');
            showFullName.value = true;
          }}
        >
          show full name
        </button>
        <button
          onClick$={() => {
            console.log('set showFullName.value = false');
            showFullName.value = false;
          }}
        >
          only show first name
        </button>
      </div>
      <div>
        <button
          onClick$={() => {
            console.log('set firstName.value = Leo');
            firstName.value = 'Leo';
          }}
        >
          Set first name to Leo
        </button>
        <button
          onClick$={() => {
            console.log('set lastName.value = Nerd');
            lastName.value = 'Nerd';
          }}
        >
          Set last name to Nerd
        </button>
      </div>
      <div>
        <button
          onClick$={() => {
            console.log('set firstName.value = Una');
            firstName.value = 'Una';
          }}
        >
          Set first name to Una
        </button>
        <button
          onClick$={() => {
            console.log('set lastName.value = Chen');
            lastName.value = 'Chen';
          }}
        >
          Set last name to Chen
        </button>
      </div>
    </div>
  );
});
```
